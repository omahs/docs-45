"use strict";(self.webpackChunkdocs_oasis_dev=self.webpackChunkdocs_oasis_dev||[]).push([[1146],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),p=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return i.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},c=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=p(n),h=a,m=c["".concat(s,".").concat(h)]||c[h]||u[h]||r;return n?i.createElement(m,o(o({ref:t},d),{},{components:n})):i.createElement(m,o({ref:t},d))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var p=2;p<r;p++)o[p]=n[p];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}c.displayName="MDXCreateElement"},2843:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var i=n(7462),a=(n(7294),n(3905));const r={},o="ADR 0001: Multiple Roots Under the Tendermint Application Hash",l={unversionedId:"adrs/0001-tm-multi-root-apphash",id:"adrs/0001-tm-multi-root-apphash",title:"ADR 0001: Multiple Roots Under the Tendermint Application Hash",description:"Component",source:"@site/docs/adrs/0001-tm-multi-root-apphash.md",sourceDirName:"adrs",slug:"/adrs/0001-tm-multi-root-apphash",permalink:"/adrs/0001-tm-multi-root-apphash",draft:!1,editUrl:"https://github.com/oasisprotocol/adrs/edit/main/0001-tm-multi-root-apphash.md",tags:[],version:"current",lastUpdatedAt:1674490900,formattedLastUpdatedAt:"Jan 23, 2023",frontMatter:{},sidebar:"adrs",previous:{title:"Architectural Decision Records",permalink:"/adrs"},next:{title:"ADR 0002: Go Modules Compatible Git Tags",permalink:"/adrs/0002-go-modules-compatible-git-tags"}},s={},p=[{value:"Component",id:"component",level:2},{value:"Changelog",id:"changelog",level:2},{value:"Status",id:"status",level:2},{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Alternatives",id:"alternatives",level:2},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"References",id:"references",level:2}],d={toc:p};function u(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"adr-0001-multiple-roots-under-the-tendermint-application-hash"},"ADR 0001: Multiple Roots Under the Tendermint Application Hash"),(0,a.kt)("h2",{id:"component"},"Component"),(0,a.kt)("p",null,"Oasis Core"),(0,a.kt)("h2",{id:"changelog"},"Changelog"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"2020-08-06: Added consequence for state checkpoints"),(0,a.kt)("li",{parentName:"ul"},"2020-07-28: Initial version")),(0,a.kt)("h2",{id:"status"},"Status"),(0,a.kt)("p",null,"Accepted"),(0,a.kt)("h2",{id:"context"},"Context"),(0,a.kt)("p",null,"Currently the Tendermint ABCI application hash is equal to the consensus state\nroot for a specific height. In order to allow additional uses, like proving to\nlight clients that specific events have been emitted in a block, we should make\nthe application hash be derivable from potentially different kinds of roots."),(0,a.kt)("h2",{id:"decision"},"Decision"),(0,a.kt)("p",null,"The proposed design is to derive the Tendermint ABCI application hash by hashing\nall the different roots as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"AppHash := H(Context || Root_0 || ... || Root_n)\n")),(0,a.kt)("p",null,"Where:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"H")," is the SHA-512/256 hash function."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Context")," is the string ",(0,a.kt)("inlineCode",{parentName:"li"},"oasis-core/tendermint: roots"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Root_i")," is the fixed-size SHA-512/256 root hash of the specified root.")),(0,a.kt)("p",null,"Currently, the only root would be the existing consensus state root at index 0."),(0,a.kt)("p",null,"To implement this change the following modifications would be required:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Update the ABCI multiplexer's ",(0,a.kt)("inlineCode",{parentName:"p"},"Commit")," method to calculate and return the\napplication hash using the scheme specified above.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Update the consensus API ",(0,a.kt)("inlineCode",{parentName:"p"},"SignedHeader")," response to include the\n",(0,a.kt)("inlineCode",{parentName:"p"},"UntrustedStateRoot")," (the untrusted prefix denotes that the user must verify\nthat the state root corresponds to ",(0,a.kt)("inlineCode",{parentName:"p"},"AppHash")," provided in the signed header in\n",(0,a.kt)("inlineCode",{parentName:"p"},"Meta"),")."),(0,a.kt)("p",{parentName:"li"},"When new roots will be added in the future, both ",(0,a.kt)("inlineCode",{parentName:"p"},"Block")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"SignedHeader"),"\nwill need to include them all."))),(0,a.kt)("h2",{id:"alternatives"},"Alternatives"),(0,a.kt)("p",null,"The proposed design is simple and assumes that the number of additional roots is\nsmall and thus can always be included in signed headers. An alternative scheme\nwould be to Merkelize the roots in a binary Merkle tree (like the one used for\nour MKVS), but this would add complexity and likely require more round trips for\ncommon use cases."),(0,a.kt)("h2",{id:"consequences"},"Consequences"),(0,a.kt)("h3",{id:"positive"},"Positive"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"This would open the path to including different kinds of provable data (e.g.,\nin addition to state) as part of any consensus-layer block.")),(0,a.kt)("h3",{id:"negative"},"Negative"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"As this changes the application hash, this would be a breaking change for the\nconsensus layer.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Since we are simply hashing all the roots together, all of them need to be\nincluded in the signed headers returned to light clients."))),(0,a.kt)("h3",{id:"neutral"},"Neutral"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Consensus state checkpoints will need to contain data for multiple roots.")),(0,a.kt)("h2",{id:"references"},"References"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/tendermint/tendermint/pull/5134"},"tendermint#5134"))))}u.isMDXComponent=!0}}]);