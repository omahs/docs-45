"use strict";(self.webpackChunkdocs_oasis_dev=self.webpackChunkdocs_oasis_dev||[]).push([[355],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=a.createContext({}),l=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=l(e.components);return a.createElement(p.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,p=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),u=l(n),m=o,h=u["".concat(p,".").concat(m)]||u[m]||c[m]||r;return n?a.createElement(h,s(s({ref:t},d),{},{components:n})):a.createElement(h,s({ref:t},d))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,s=new Array(r);s[0]=u;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i.mdxType="string"==typeof e?e:o,s[1]=i;for(var l=2;l<r;l++)s[l]=n[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},8728:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>c,frontMatter:()=>r,metadata:()=>i,toc:()=>l});var a=n(7462),o=(n(7294),n(3905));const r={},s="ADR 0006: Consensus Governance",i={unversionedId:"adrs/0006-consensus-governance",id:"adrs/0006-consensus-governance",title:"ADR 0006: Consensus Governance",description:"Component",source:"@site/docs/adrs/0006-consensus-governance.md",sourceDirName:"adrs",slug:"/adrs/0006-consensus-governance",permalink:"/adrs/0006-consensus-governance",draft:!1,editUrl:"https://github.com/oasisprotocol/adrs/edit/main/0006-consensus-governance.md",tags:[],version:"current",lastUpdatedAt:1674490900,formattedLastUpdatedAt:"Jan 23, 2023",frontMatter:{},sidebar:"adrs",previous:{title:"ADR 0005: Runtime Compute Node Slashing",permalink:"/adrs/0005-runtime-compute-slashing"},next:{title:"ADR 0007: Improved Random Beacon",permalink:"/adrs/0007-improved-random-beacon"}},p={},l=[{value:"Component",id:"component",level:2},{value:"Changelog",id:"changelog",level:2},{value:"Status",id:"status",level:2},{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"State",id:"state",level:3},{value:"Staking",id:"staking",level:4},{value:"Governance",id:"governance",level:4},{value:"Genesis Document",id:"genesis-document",level:3},{value:"Transaction Methods",id:"transaction-methods",level:3},{value:"Submit Proposal",id:"submit-proposal",level:4},{value:"Vote",id:"vote",level:4},{value:"Queries",id:"queries",level:3},{value:"Tallying",id:"tallying",level:3},{value:"Proposal Content Execution",id:"proposal-content-execution",level:3},{value:"Upgrade Proposal",id:"upgrade-proposal",level:4},{value:"Cancel Upgrade Proposal",id:"cancel-upgrade-proposal",level:4},{value:"Consensus Parameters",id:"consensus-parameters",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"References",id:"references",level:2}],d={toc:l};function c(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"adr-0006-consensus-governance"},"ADR 0006: Consensus Governance"),(0,o.kt)("h2",{id:"component"},"Component"),(0,o.kt)("p",null,"Oasis Core"),(0,o.kt)("h2",{id:"changelog"},"Changelog"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"2021-03-30: Update name of the CastVote method's body"),(0,o.kt)("li",{parentName:"ul"},"2021-01-06: Update API to include Proposals() method"),(0,o.kt)("li",{parentName:"ul"},"2020-12-08: Updates to match the actual implementation"),(0,o.kt)("li",{parentName:"ul"},"2020-10-27: Voting period in epochs, min upgrade cancellation difference,\nfailed proposal state"),(0,o.kt)("li",{parentName:"ul"},"2020-10-16: Initial draft")),(0,o.kt)("h2",{id:"status"},"Status"),(0,o.kt)("p",null,"Accepted"),(0,o.kt)("h2",{id:"context"},"Context"),(0,o.kt)("p",null,"Currently the consensus layer does not contain any on-chain governance\nmechanism so any network upgrades need to be carefully coordinated off-chain.\nAn on-chain governance mechanism would allow upgrades to be handled in a more\ncontrolled (and automatable) manner without introducing the risk of corrupting\nstate."),(0,o.kt)("h2",{id:"decision"},"Decision"),(0,o.kt)("p",null,"This proposal introduces a minimal on-chain governance mechanism where anyone\ncan submit governance proposals and the validators can vote where one base unit\nof delegated stake counts as one vote."),(0,o.kt)("p",null,"The high-level overview is as follows:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"A new governance API")," is added to the consensus layer and its Tendermint\nbased implementation. It supports transactions for submitting proposals and\nvoting on proposals. It supports queries for listing current proposals and\nvotes for any given proposal.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Two governance proposal kinds are supported"),", a consensus layer upgrade\nproposal (where the content is basically the existing upgrade descriptor) and\nthe cancellation of a pending upgrade."))),(0,o.kt)("p",null,"A proposal is created through a ",(0,o.kt)("em",{parentName:"p"},"submit proposal")," transaction and requires a\nminimum deposit (which is later refunded in case the proposal passes). Once a\nproposal is successfully submitted the voting period starts. Entities that are\npart of the validator set may cast votes for the proposal. After the voting\nperiod completes, the votes are tallied and the proposal either passes or is\nrejected."),(0,o.kt)("p",null,"In case the proposal passes, the actions specified in the content of the propsal\nare executed. Currently the only actions are scheduling of an upgrade by\npublishing an upgrade descriptor or cancelling a previously passed upgrade."),(0,o.kt)("h3",{id:"state"},"State"),(0,o.kt)("h4",{id:"staking"},"Staking"),(0,o.kt)("p",null,"This proposal adds the following consensus layer state in the staking module:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Governance deposits account balance (",(0,o.kt)("inlineCode",{parentName:"strong"},"0x59"),")"),", similar to the common pool.")),(0,o.kt)("h4",{id:"governance"},"Governance"),(0,o.kt)("p",null,"This proposal adds the following consensus layer state in the governance module:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Next proposal identifier (",(0,o.kt)("inlineCode",{parentName:"strong"},"0x80"),")")),(0,o.kt)("p",{parentName:"li"},"The next proposal identifier is stored as a CBOR-serialized ",(0,o.kt)("inlineCode",{parentName:"p"},"uint64"),".")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"List of proposals (",(0,o.kt)("inlineCode",{parentName:"strong"},"0x81"),")")),(0,o.kt)("p",{parentName:"li"},"Each proposal is stored under a separate storage key with the following key\nformat:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre"},"0x81 <proposal-id (uint64)>\n")),(0,o.kt)("p",{parentName:"li"},"And CBOR-serialized value:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-golang"},'// ProposalState is the state of the proposal.\ntype ProposalState uint8\n\nconst (\n    StateActive   ProposalState = 1\n    StatePassed   ProposalState = 2\n    StateRejected ProposalState = 3\n    StateFailed   ProposalState = 4\n)\n\n// Proposal is a consensus upgrade proposal.\ntype Proposal struct {\n    // ID is the unique identifier of the proposal.\n    ID uint64 `json:"id"`\n    // Submitter is the address of the proposal submitter.\n    Submitter staking.Address `json:"submitter"`\n    // State is the state of the proposal.\n    State ProposalState `json:"state"`\n    // Deposit is the deposit attached to the proposal.\n    Deposit quantity.Quantity `json:"deposit"`\n\n    // Content is the content of the proposal.\n    Content ProposalContent `json:"content"`\n\n    // CreatedAt is the epoch at which the proposal was created.\n    CreatedAt beacon.EpochTime `json:"created_at"`\n    // ClosesAt is the epoch at which the proposal will close and votes will\n    // be tallied.\n    ClosesAt beacon.EpochTime `json:"closes_at"`\n\n    // Results are the final tallied results after the voting period has\n    // ended.\n    Results map[Vote]quantity.Quantity `json:"results,omitempty"`\n    // InvalidVotes is the number of invalid votes after tallying.\n    InvalidVotes uint64 `json:"invalid_votes,omitempty"`\n}\n'))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"List of active proposals (",(0,o.kt)("inlineCode",{parentName:"strong"},"0x82"),")")),(0,o.kt)("p",{parentName:"li"},"Each active proposal (one that has not yet closed) is stored under a separate\nstorage key with the following key format:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre"},"0x82 <closes-at-epoch (uint64)> <proposal-id (uint64)>\n")),(0,o.kt)("p",{parentName:"li"},"The value is empty as the proposal ID can be inferred from the key.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"List of votes (",(0,o.kt)("inlineCode",{parentName:"strong"},"0x83"),")")),(0,o.kt)("p",{parentName:"li"},"Each vote is stored under a separate storage key with the following key\nformat:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre"},"0x83 <proposal-id (uint64)> <voter-address (staking.Address)>\n")),(0,o.kt)("p",{parentName:"li"},"And CBOR-serialized value:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-golang"},"// Vote is a governance vote.\ntype Vote uint8\n\nconst (\n    VoteYes     Vote = 1\n    VoteNo      Vote = 2\n    VoteAbstain Vote = 3\n)\n"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"List of pending upgrades (",(0,o.kt)("inlineCode",{parentName:"strong"},"0x84"),")")),(0,o.kt)("p",{parentName:"li"},"Each pending upgrade is stored under a separate storage key with the following\nkey format:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre"},"0x84 <upgrade-epoch (uint64)> <proposal-id (uint64)>\n")),(0,o.kt)("p",{parentName:"li"},"The value is empty as the proposal upgrade descriptor can be obtained via\nproposal that can be inferred from the key.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Parameters (",(0,o.kt)("inlineCode",{parentName:"strong"},"0x85"),")")),(0,o.kt)("p",{parentName:"li"},"Governance consensus parameters."),(0,o.kt)("p",{parentName:"li"},"With CBOR-serialized value:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-golang"},'// ConsensusParameters are the governance consensus parameters.\ntype ConsensusParameters struct {\n    // GasCosts are the governance transaction gas costs.\n    GasCosts transaction.Costs `json:"gas_costs,omitempty"`\n\n    // MinProposalDeposit is the number of base units that are deposited when\n    // creating a new proposal.\n    MinProposalDeposit quantity.Quantity `json:"min_proposal_deposit,omitempty"`\n\n    // VotingPeriod is the number of epochs after which the voting for a proposal\n    // is closed and the votes are tallied.\n    VotingPeriod beacon.EpochTime `json:"voting_period,omitempty"`\n\n    // Quorum is he minimum percentage of voting power that needs to be cast on\n    // a proposal for the result to be valid.\n    Quorum uint8 `json:"quorum,omitempty"`\n\n    // Threshold is the minimum percentage of VoteYes votes in order for a\n    // proposal to be accepted.\n    Threshold uint8 `json:"threshold,omitempty"`\n\n    // UpgradeMinEpochDiff is the minimum number of epochs between the current\n    // epoch and the proposed upgrade epoch for the upgrade proposal to be valid.\n    // This is also the minimum number of epochs between two pending upgrades.\n    UpgradeMinEpochDiff beacon.EpochTime `json:"upgrade_min_epoch_diff,omitempty"`\n\n    // UpgradeCancelMinEpochDiff is the minimum number of epochs between the current\n    // epoch and the proposed upgrade epoch for the upgrade cancellation proposal to be valid.\n    UpgradeCancelMinEpochDiff beacon.EpochTime `json:"upgrade_cancel_min_epoch_diff,omitempty"`\n}\n')))),(0,o.kt)("h3",{id:"genesis-document"},"Genesis Document"),(0,o.kt)("p",null,"The genesis document needs to be updated to include a ",(0,o.kt)("inlineCode",{parentName:"p"},"governance")," field with\nany initial state (see ",(0,o.kt)("a",{parentName:"p",href:"#state"},(0,o.kt)("em",{parentName:"a"},"State")),") and consensus parameters (see ",(0,o.kt)("a",{parentName:"p",href:"#consensus-parameters"},(0,o.kt)("em",{parentName:"a"},"Consensus\nParameters")),") for the governance service."),(0,o.kt)("h3",{id:"transaction-methods"},"Transaction Methods"),(0,o.kt)("p",null,"This proposal adds the following transaction methods in the governance module:"),(0,o.kt)("h4",{id:"submit-proposal"},"Submit Proposal"),(0,o.kt)("p",null,"Proposal submission enables a new consensus layer governance proposal to be\ncreated."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Method name:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"governance.SubmitProposal\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Body:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-golang"},'// ProposalContent is a consensus layer governance proposal content.\ntype ProposalContent struct {\n    Upgrade       *UpgradeProposal       `json:"upgrade,omitempty"`\n    CancelUpgrade *CancelUpgradeProposal `json:"cancel_upgrade,omitempty"`\n}\n\n// UpgradeProposal is an upgrade proposal.\ntype UpgradeProposal struct {\n    upgrade.Descriptor\n}\n\n// CancelUpgradeProposal is an upgrade cancellation proposal.\ntype CancelUpgradeProposal struct {\n    // ProposalID is the identifier of the pending upgrade proposal.\n    ProposalID uint64 `json:"proposal_id"`\n}\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Fields:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"upgrade")," (optional) specifies an upgrade proposal."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"cancel_upgrade")," (optional) specifies an upgrade cancellation proposal.")),(0,o.kt)("p",null,"Exactly one of the proposal kind fields needs to be non-nil, otherwise the\nproposal is considered malformed."),(0,o.kt)("p",null,"Upon processing any proposal the following steps are first performed:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The account indicated by the signer is loaded.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"If the account balance is less than ",(0,o.kt)("inlineCode",{parentName:"p"},"min_proposal_deposit"),", the method call\nfails with ",(0,o.kt)("inlineCode",{parentName:"p"},"ErrInsufficientBalance"),"."))),(0,o.kt)("p",null,"Upon processing an ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"UpgradeProposal"))," the following steps are then performed:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The upgrade descriptor is checked for basic internal validity. If the check\nfails, the method call fails with ",(0,o.kt)("inlineCode",{parentName:"p"},"ErrInvalidArgument"),".")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The upgrade descriptor's ",(0,o.kt)("inlineCode",{parentName:"p"},"epoch")," field is compared with the current epoch. If\nthe specified epoch is not at least ",(0,o.kt)("inlineCode",{parentName:"p"},"upgrade_min_epoch_diff")," epochs ahead of\nthe current epoch, the method call fails with ",(0,o.kt)("inlineCode",{parentName:"p"},"ErrUpgradeTooSoon"),".")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The set of pending upgrades is checked to make sure that no upgrades are\ncurrently pending within ",(0,o.kt)("inlineCode",{parentName:"p"},"upgrade_min_epoch_diff")," epochs of the upgrade\ndescriptor's ",(0,o.kt)("inlineCode",{parentName:"p"},"epoch")," field. If there is such an existing upgrade pending, the\nmethod call fails with ",(0,o.kt)("inlineCode",{parentName:"p"},"ErrUpgradeAlreadyPending"),"."))),(0,o.kt)("p",null,"Upon processing a ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"CancelUpgradeProposal"))," the following steps are then\nperformed:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The set of pending upgrades is checked to make sure that the given upgrade\nproposal is currently pending to be executed. If there is no such upgrade, the\nmethod call fails with ",(0,o.kt)("inlineCode",{parentName:"p"},"ErrNoSuchUpgrade"),".")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The upgrade descriptor's ",(0,o.kt)("inlineCode",{parentName:"p"},"epoch")," field is compared with the current epoch. If\nthe specified epoch is not at least ",(0,o.kt)("inlineCode",{parentName:"p"},"upgrade_cancel_min_epoch_diff")," epochs\nahead of the current epoch, the method call fails with ",(0,o.kt)("inlineCode",{parentName:"p"},"ErrUpgradeTooSoon"),"."))),(0,o.kt)("p",null,"Upon processing any proposal the following steps are then performed:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The ",(0,o.kt)("inlineCode",{parentName:"p"},"min_proposal_deposit")," base units are transferred from the signer's\naccount to the governance service's ",(0,o.kt)("em",{parentName:"p"},"proposal deposit account"),".")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The signer's account is saved.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"A new proposal is created and assigned an identifier.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The corresponding ",(0,o.kt)("inlineCode",{parentName:"p"},"ProposalSubmittedEvent")," is emitted with the following\nstructure:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-golang"},'type ProposalSubmittedEvent struct {\n    // ID is the unique identifier of a proposal.\n    ID uint64 `json:"id"`\n    // Submitter is the staking account address of the submitter.\n    Submitter staking.Address `json:"submitter"`\n}\n'))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The corresponding ",(0,o.kt)("inlineCode",{parentName:"p"},"staking.TransferEvent")," is emitted, indicating transfer from\nthe submitter's account to the ",(0,o.kt)("em",{parentName:"p"},"proposal deposit account"),"."))),(0,o.kt)("h4",{id:"vote"},"Vote"),(0,o.kt)("p",null,"Voting for submitted consensus layer governance proposals."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Method name:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"governance.CastVote\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Body:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-golang"},'type ProposalVote struct {\n    // ID is the unique identifier of a proposal.\n    ID uint64 `json:"id"`\n    // Vote is the vote.\n    Vote Vote `json:"vote"`\n}\n')),(0,o.kt)("p",null,"Upon processing a vote the following steps are performed:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The entity descriptor corresponding to the transaction signer is fetched. In\ncase no such entity exists, the method call fails with ",(0,o.kt)("inlineCode",{parentName:"p"},"ErrNotEligible"),".")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"It is checked whether any entity's nodes are in the current validator set. In\ncase they are not, the method call fails with ",(0,o.kt)("inlineCode",{parentName:"p"},"ErrNotEligible"),".")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The proposal identified by ",(0,o.kt)("inlineCode",{parentName:"p"},"id")," is loaded. If the proposal does not exist,\nthe method call fails with ",(0,o.kt)("inlineCode",{parentName:"p"},"ErrNoSuchProposal"),".")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"If the proposal's state is not ",(0,o.kt)("inlineCode",{parentName:"p"},"StateActive"),", the method call fails with\n",(0,o.kt)("inlineCode",{parentName:"p"},"ErrVotingIsClosed"),".")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The vote is added to the list of votes. If the vote already exists, it is\noverwritten.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The corresponding ",(0,o.kt)("inlineCode",{parentName:"p"},"VoteEvent")," is emitted with the following structure:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-golang"},'type VoteEvent struct {\n    // ID is the unique identifier of a proposal.\n    ID uint64 `json:"id"`\n    // Submitter is the staking account address of the submitter.\n    Submitter staking.Address `json:"submitter"`\n    // Vote is the cast vote.\n    Vote Vote `json:"vote"`\n}\n')))),(0,o.kt)("h3",{id:"queries"},"Queries"),(0,o.kt)("p",null,"This proposal introduces the following query methods in the governance module:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-golang"},'type Backend interface {\n    // ActiveProposals returns a list of all proposals that have not yet closed.\n    ActiveProposals(ctx context.Context, height int64) ([]*Proposal, error)\n\n    // Proposals returns a list of all proposals.\n    Proposals(ctx context.Context, height int64) ([]*Proposal, error)\n\n    // Proposal looks up a specific proposal.\n    Proposal(ctx context.Context, query *ProposalQuery) (*Proposal, error)\n\n    // Votes looks up votes for a specific proposal.\n    Votes(ctx context.Context, query *ProposalQuery) ([]*VoteEntry, error)\n\n    // PendingUpgrades returns a list of all pending upgrades.\n    PendingUpgrades(ctx context.Context, height int64) ([]*upgrade.Descriptor, error)\n\n    // StateToGenesis returns the genesis state at specified block height.\n    StateToGenesis(ctx context.Context, height int64) (*Genesis, error)\n\n    // ConsensusParameters returns the governance consensus parameters.\n    ConsensusParameters(ctx context.Context, height int64) (*ConsensusParameters, error)\n\n    // GetEvents returns the events at specified block height.\n    GetEvents(ctx context.Context, height int64) ([]*Event, error)\n\n    // WatchEvents returns a channel that produces a stream of Events.\n    WatchEvents(ctx context.Context) (<-chan *Event, pubsub.ClosableSubscription, error)\n}\n\n// ProposalQuery is a proposal query.\ntype ProposalQuery struct {\n    Height int64  `json:"height"`\n    ID     uint64 `json:"id"`\n}\n\n// VoteEntry contains data about a cast vote.\ntype VoteEntry struct {\n    Voter staking.Address `json:"voter"`\n    Vote  Vote            `json:"vote"`\n}\n\n// Event signifies a governance event, returned via GetEvents.\ntype Event struct {\n    Height int64     `json:"height,omitempty"`\n    TxHash hash.Hash `json:"tx_hash,omitempty"`\n\n    ProposalSubmitted *ProposalSubmittedEvent `json:"proposal_submitted,omitempty"`\n    ProposalExecuted  *ProposalExecutedEvent  `json:"proposal_executed,omitempty"`\n    ProposalFinalized *ProposalFinalizedEvent `json:"proposal_finalized,omitempty"`\n    Vote              *VoteEvent              `json:"vote,omitempty"`\n}\n')),(0,o.kt)("h3",{id:"tallying"},"Tallying"),(0,o.kt)("p",null,"In ",(0,o.kt)("inlineCode",{parentName:"p"},"EndBlock")," the list of active proposals is checked to see if there was an\nepoch transition in this block. If there was, the following steps are performed\nfor each proposal that should be closed at the current epoch:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"A mapping of current validator entity addresses to their respective active\nescrow balances is prepared.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"A results mapping from ",(0,o.kt)("inlineCode",{parentName:"p"},"Vote")," to number of votes is initialized in the\nproposal's ",(0,o.kt)("inlineCode",{parentName:"p"},"results")," field.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Votes from the list of votes for the given proposal are iterated and the\naddress of each vote is looked up in the prepared entity address mapping. The\ncorresponding number of votes (on the principle of 1 base unit equals one\nvote) are added to the results mapping based on the voted option. Any votes\nthat are not from the current validator set are ignored and the\n",(0,o.kt)("inlineCode",{parentName:"p"},"invalid_votes")," field is incremented for each such vote.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"In case the percentage of votes relative to the total voting power is less\nthan ",(0,o.kt)("inlineCode",{parentName:"p"},"quorum"),", the proposal is rejected.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"In case the percentage of ",(0,o.kt)("inlineCode",{parentName:"p"},"VoteYes")," votes relative to all valid votes is less\nthan ",(0,o.kt)("inlineCode",{parentName:"p"},"threshold"),", the proposal is rejected.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Otherwise the proposal is passed.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The proposal's status is changed to either ",(0,o.kt)("inlineCode",{parentName:"p"},"StatePassed")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"StateRejected"),"\nand the proposal is saved.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The proposal is removed from the list of active proposals.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"In case the proposal has been passed, the proposal content is executed. If\nproposal execution fails, the proposal's state is changed to ",(0,o.kt)("inlineCode",{parentName:"p"},"StateFailed"),".")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The corresponding ",(0,o.kt)("inlineCode",{parentName:"p"},"ProposalFinalizedEvent")," is emitted with the following\nstructure:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-golang"},'type ProposalFinalizedEvent struct {\n    // ID is the unique identifier of a proposal.\n    ID uint64 `json:"id"`\n    // State is the new proposal state.\n    State ProposalState `json:"state"`\n}\n'))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"In case the proposal has been passed, the deposit is transferred back to the\nproposal submitter and a corresponding ",(0,o.kt)("inlineCode",{parentName:"p"},"staking.TransferEvent")," is emitted,\nindicating transfer from the ",(0,o.kt)("em",{parentName:"p"},"proposal deposit account")," to the submitter's\naccount.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"In case the proposal has been rejected, the deposit is transferred to the\ncommon pool and a corresponding ",(0,o.kt)("inlineCode",{parentName:"p"},"staking.TransferEvent")," is emitted,\nindicating transfer from the ",(0,o.kt)("em",{parentName:"p"},"proposal deposit account")," to the common pool\naccount."))),(0,o.kt)("h3",{id:"proposal-content-execution"},"Proposal Content Execution"),(0,o.kt)("p",null,"After any proposal is successfully executed the corresponding\n",(0,o.kt)("inlineCode",{parentName:"p"},"ProposalExecutedEvent")," is emitted with the following structure:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-golang"},'type ProposalExecutedEvent struct {\n    // ID is the unique identifier of a proposal.\n    ID uint64 `json:"id"`\n}\n')),(0,o.kt)("h4",{id:"upgrade-proposal"},"Upgrade Proposal"),(0,o.kt)("p",null,"The set of pending upgrades is checked to make sure that no upgrades are\ncurrently pending within ",(0,o.kt)("inlineCode",{parentName:"p"},"upgrade_min_epoch_diff")," of the upgrade descriptor's\n",(0,o.kt)("inlineCode",{parentName:"p"},"epoch")," field. If there is such an existing pending upgrade the upgrade proposal\nexecution fails."),(0,o.kt)("p",null,"When an upgrade proposal is executed, a new entry is added to the list of\npending upgrades using ",(0,o.kt)("inlineCode",{parentName:"p"},"epoch")," as ",(0,o.kt)("inlineCode",{parentName:"p"},"<upgrade-epoch>"),"."),(0,o.kt)("p",null,"On each epoch transition (as part of ",(0,o.kt)("inlineCode",{parentName:"p"},"BeginBlock"),") it is checked whether a\npending upgrade is scheduled for that epoch. In case it is and we are not\nrunning the new version, the consensus layer will panic. Otherwise, the pending\nupgrade proposal is removed."),(0,o.kt)("h4",{id:"cancel-upgrade-proposal"},"Cancel Upgrade Proposal"),(0,o.kt)("p",null,"When a cancel upgrade proposal is executed, the proposal identified by\n",(0,o.kt)("inlineCode",{parentName:"p"},"proposal_id")," is looked up and removed from the list of pending upgrades. In\ncase the pending upgrade does not exist anymore, no action is performed."),(0,o.kt)("h3",{id:"consensus-parameters"},"Consensus Parameters"),(0,o.kt)("p",null,"This proposal introduces the following new consensus parameters in the\ngovernance module:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"gas_costs")," (transaction.Costs) are the governance transaction gas costs.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"min_proposal_deposit")," (base units) specifies the number of base units that\nare deposited when creating a new proposal.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"voting_period")," (epochs) specifies the number of epochs after which the voting\nfor a proposal is closed and the votes are tallied.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"quorum")," (uint8: ","[","0,100","]",") specifies the minimum percentage of voting power\nthat needs to be cast on a proposal for the result to be valid.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"threshold")," (uint8: ","[","0,100","]",") specifies the minimum percentage of ",(0,o.kt)("inlineCode",{parentName:"p"},"VoteYes"),"\nvotes in order for a proposal to be accepted.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"upgrade_min_epoch_diff")," (epochs) specifies the minimum number of epochs\nbetween the current epoch and the proposed upgrade epoch for the upgrade\nproposal to be valid. Additionally specifies the minimum number of epochs\nbetween two consecutive pending upgrades.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"upgrade_cancel_min_epoch_diff")," (epochs) specifies the minimum number of\nepochs between the current epoch and the proposed upgrade epoch for the\nupgrade cancellation proposal to be valid."))),(0,o.kt)("p",null,"The following parameter sanity checks are introduced:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Product of ",(0,o.kt)("inlineCode",{parentName:"p"},"quorum")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"threshold")," must be 2/3+.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"voting_period")," must be less than ",(0,o.kt)("inlineCode",{parentName:"p"},"upgrade_min_epoch_diff")," and\n",(0,o.kt)("inlineCode",{parentName:"p"},"upgrade_cancel_min_epoch_diff"),"."))),(0,o.kt)("h2",{id:"consequences"},"Consequences"),(0,o.kt)("h3",{id:"positive"},"Positive"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The consensus layer can coordinate on upgrades.")),(0,o.kt)("h3",{id:"negative"},"Negative"),(0,o.kt)("h3",{id:"neutral"},"Neutral"),(0,o.kt)("h2",{id:"references"},"References"))}c.isMDXComponent=!0}}]);