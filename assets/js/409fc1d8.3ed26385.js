"use strict";(self.webpackChunkdocs_oasis_dev=self.webpackChunkdocs_oasis_dev||[]).push([[651],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>d});var s=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);t&&(s=s.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,s)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,s,a=function(e,t){if(null==e)return{};var n,s,a={},i=Object.keys(e);for(s=0;s<i.length;s++)n=i[s],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(s=0;s<i.length;s++)n=i[s],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var u=s.createContext({}),l=function(e){var t=s.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},m=function(e){var t=l(e.components);return s.createElement(u.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return s.createElement(s.Fragment,{},t)}},p=s.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,u=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),p=l(n),d=a,h=p["".concat(u,".").concat(d)]||p[d]||c[d]||i;return n?s.createElement(h,r(r({ref:t},m),{},{components:n})):s.createElement(h,r({ref:t},m))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,r=new Array(i);r[0]=p;var o={};for(var u in t)hasOwnProperty.call(t,u)&&(o[u]=t[u]);o.originalType=e,o.mdxType="string"==typeof e?e:a,r[1]=o;for(var l=2;l<i;l++)r[l]=n[l];return s.createElement.apply(null,r)}return s.createElement.apply(null,n)}p.displayName="MDXCreateElement"},9455:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>r,default:()=>c,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var s=n(7462),a=(n(7294),n(3905));const i={},r="ADR 0011: Incoming Runtime Messages",o={unversionedId:"adrs/0011-incoming-runtime-messages",id:"adrs/0011-incoming-runtime-messages",title:"ADR 0011: Incoming Runtime Messages",description:"Component",source:"@site/docs/adrs/0011-incoming-runtime-messages.md",sourceDirName:"adrs",slug:"/adrs/0011-incoming-runtime-messages",permalink:"/adrs/0011-incoming-runtime-messages",draft:!1,editUrl:"https://github.com/oasisprotocol/adrs/edit/main/0011-incoming-runtime-messages.md",tags:[],version:"current",lastUpdatedAt:1674490900,formattedLastUpdatedAt:"Jan 23, 2023",frontMatter:{},sidebar:"adrs",previous:{title:"ADR 0010: VRF-based Committee Elections",permalink:"/adrs/0010-vrf-elections"},next:{title:"ADR 0012: Runtime Message Results",permalink:"/adrs/0012-runtime-message-results"}},u={},l=[{value:"Component",id:"component",level:2},{value:"Changelog",id:"changelog",level:2},{value:"Status",id:"status",level:2},{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Incoming Message",id:"incoming-message",level:3},{value:"Executor Commitments",id:"executor-commitments",level:3},{value:"Runtime Block Header",id:"runtime-block-header",level:3},{value:"Runtime Descriptor",id:"runtime-descriptor",level:3},{value:"State",id:"state",level:3},{value:"Transaction Methods",id:"transaction-methods",level:3},{value:"Submit Message",id:"submit-message",level:4},{value:"Queries",id:"queries",level:3},{value:"Runtime Host Protocol",id:"runtime-host-protocol",level:3},{value:"Rust Runtime Support Library",id:"rust-runtime-support-library",level:3},{value:"Executor Processing",id:"executor-processing",level:3},{value:"Runtime Processing",id:"runtime-processing",level:3},{value:"Root Hash Commitment Processing",id:"root-hash-commitment-processing",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3}],m={toc:l};function c(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,s.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"adr-0011-incoming-runtime-messages"},"ADR 0011: Incoming Runtime Messages"),(0,a.kt)("h2",{id:"component"},"Component"),(0,a.kt)("p",null,"Oasis Core"),(0,a.kt)("h2",{id:"changelog"},"Changelog"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"2022-01-07: Update based on insights from implementation"),(0,a.kt)("li",{parentName:"ul"},"2021-12-09: Introduce an explicit fee field, clarify token transfers"),(0,a.kt)("li",{parentName:"ul"},"2021-10-26: Initial draft")),(0,a.kt)("h2",{id:"status"},"Status"),(0,a.kt)("p",null,"Accepted"),(0,a.kt)("h2",{id:"context"},"Context"),(0,a.kt)("p",null,"There is currently a single mechanism through which the consensus layer and a\nruntime may interact in a consistent and secure manner. This is the mechanism\nof runtime messages that can be emitted by runtimes (see ",(0,a.kt)("a",{parentName:"p",href:"/adrs/0003-consensus-runtime-token-transfer"},"ADR 3"),") and allows\nthe consensus layer to act on a runtime's behalf. This mechanism is currently\nused for ",(0,a.kt)("em",{parentName:"p"},"pulling")," tokens from consensus layer accounts that have previously\nset proper allowances and for updating the runtime descriptor when the runtime\ngovernance model (see ",(0,a.kt)("a",{parentName:"p",href:"/adrs/0004-runtime-governance"},"ADR 4"),") is in effect."),(0,a.kt)("p",null,"This ADR proposes to implement the reverse mechanism where anyone issuing a\ntransaction at the consensus layer can queue arbitrary messages for processing\nby the runtime in its next round."),(0,a.kt)("h2",{id:"decision"},"Decision"),(0,a.kt)("p",null,"On a high level this proposal affects the following components:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"A new transaction method ",(0,a.kt)("inlineCode",{parentName:"p"},"roothash.SubmitMsg")," is added to the roothash\nconsensus service to queue a new message for the specific runtime.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Additional per-runtime state is added to the roothash service containing the\ncurrently queued messages, sorted by arrival time.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"During processing of a round the proposer may propose to pop any number of\nmessages and process them by pushing them to the runtime, similar as it does\nfor transaction batches. This is of course subject to discrepancy detection.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"The runtime host protocol is updated to allow the host to push arbitrary\nincoming messages in addition to the transaction batch.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"The runtime descriptor is updated to include a field that specifies the\nmaximum size of the incoming message queue."))),(0,a.kt)("h3",{id:"incoming-message"},"Incoming Message"),(0,a.kt)("p",null,"Each incoming message is represented as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-golang"},'type IncomingMessage struct {\n    // ID is the unique identifier of the message.\n    ID uint64 `json:"id"`\n\n    // Caller is the address of the caller authenticated by the consensus layer.\n    Caller staking.Address `json:"caller"`\n\n    // Tag is an optional tag provided by the caller which is ignored and can be used to match\n    // processed incoming message events later.\n    Tag uint64 `json:"tag,omitempty"`\n\n    // Fee is the fee sent into the runtime as part of the message being sent.\n    // The fee is transferred before the message is processed by the runtime.\n    Fee quantity.Quantity `json:"fee,omitempty"`\n\n    // Tokens are any tokens sent into the runtime as part of the message being\n    // sent. The tokens are transferred before the message is processed by the\n    // runtime.\n    Tokens quantity.Quantity `json:"tokens,omitempty"`\n\n    // Data is arbitrary runtime-dependent data.\n    Data []byte `json:"data,omitempty"`\n}\n')),(0,a.kt)("h3",{id:"executor-commitments"},"Executor Commitments"),(0,a.kt)("p",null,"The compute results header structure is updated to include two fields that\nspecify the number and hash of incoming messages included in a batch as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-golang"},'type ComputeResultsHeader struct {\n    // ... existing fields omitted ...\n\n    // InMessagesHash is the hash of processed incoming messages.\n    InMessagesHash *hash.Hash `json:"in_msgs_hash,omitempty"`\n    // InMessagesCount is the number of processed incoming messages.\n    InMessagesCount uint32 `json:"in_msgs_count,omitempty"`\n}\n')),(0,a.kt)("p",null,"Where the hash of included incoming messages is computed as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-golang"},"// InMessagesHash returns a hash of provided incoming runtime messages.\nfunc InMessagesHash(msgs []IncomingMessage) (h hash.Hash) {\n    if len(msgs) == 0 {\n        // Special case if there are no messages.\n        h.Empty()\n        return\n    }\n    return hash.NewFrom(msgs)\n}\n")),(0,a.kt)("p",null,"Note that this also requires the enclave RAK signature (for runtimes requiring\nthe use of TEEs) to be computed over this updated new header."),(0,a.kt)("h3",{id:"runtime-block-header"},"Runtime Block Header"),(0,a.kt)("p",null,"The runtime block header is updated to include the ",(0,a.kt)("inlineCode",{parentName:"p"},"InMessagesHash")," field as\nfollows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-golang"},'type Header struct {\n    // ... existing fields omitted ...\n\n    // InMessagesHash is the hash of processed incoming messages.\n    InMessagesHash hash.Hash `json:"in_msgs_hash"`\n}\n')),(0,a.kt)("h3",{id:"runtime-descriptor"},"Runtime Descriptor"),(0,a.kt)("p",null,"This proposal updates the runtime transaction scheduler parameters (stored under\nthe ",(0,a.kt)("inlineCode",{parentName:"p"},"txn_scheduler")," field of the runtime descriptor) as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-golang"},'type TxnSchedulerParameters struct {\n    // ... existing fields omitted ...\n\n    // MaxInMessages specifies the maximum size of the incoming message queue\n    // for this runtime.\n    MaxInMessages uint32 `json:"max_in_messages,omitempty"`\n}\n')),(0,a.kt)("p",null,"It also updates the runtime staking parameters (stored under the ",(0,a.kt)("inlineCode",{parentName:"p"},"staking")," field\nof the runtime descriptor) as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-golang"},'type RuntimeStakingParameters struct {\n    // ... existing fields omitted ...\n\n    // MinInMessageFee specifies the minimum fee that the incoming message must\n    // include for the message to be queued.\n    MinInMessageFee quantity.Quantity `json:"min_in_msg_fee,omitempty"`\n}\n')),(0,a.kt)("h3",{id:"state"},"State"),(0,a.kt)("p",null,"This proposal introduces/updates the following consensus state in the roothash\nmodule:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Incoming message queue metadata (",(0,a.kt)("inlineCode",{parentName:"strong"},"0x28"),")")),(0,a.kt)("p",{parentName:"li"},"Metadata for the incoming message queue."),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre"},"0x28 <H(runtime-id) (hash.Hash)>\n")),(0,a.kt)("p",{parentName:"li"},"The value is the following CBOR-serialized structure:"),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-golang"},'type IncomingMessageQueue struct {\n    // Size contains the current size of the queue.\n    Size uint32 `json:"size,omitempty"`\n\n    // NextSequenceNumber contains the sequence number that should be used for\n    // the next queued message.\n    NextSequenceNumber uint64 `json:"next_sequence_number,omitempty"`\n}\n'))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Incoming message queue item (",(0,a.kt)("inlineCode",{parentName:"strong"},"0x29"),")")),(0,a.kt)("p",{parentName:"li"},"A queue of incoming messages pending to be delivered to the runtime in the\nnext round."),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre"},"0x29 <H(runtime-id) (hash.Hash)> <sequence-no (uint64)>\n")),(0,a.kt)("p",{parentName:"li"},"The value is a CBOR-serialized ",(0,a.kt)("inlineCode",{parentName:"p"},"IncomingMessage")," structure."))),(0,a.kt)("h3",{id:"transaction-methods"},"Transaction Methods"),(0,a.kt)("p",null,"This proposal updates the following transaction methods in the roothash module:"),(0,a.kt)("h4",{id:"submit-message"},"Submit Message"),(0,a.kt)("p",null,"The submit message method allows anyone to submit incoming runtime messages to\nbe queued for delivery to the given runtime."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Method name:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"roothash.SubmitMsg\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Body:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-golang"},'type SubmitMsg struct {\n    ID     common.Namespace  `json:"id"`\n    Fee    quantity.Quantity `json:"fee,omitempty"`\n    Tokens quantity.Quantity `json:"tokens,omitempty"`\n    Data   []byte            `json:"data,omitempty"`\n}\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Fields:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"id")," specifies the destination runtime's identifier."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"fee")," specifies the fee that should be sent into the runtime as part of the\nmessage being sent. The fee is transferred before the message is processed by\nthe runtime."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"tokens")," specifies any tokens to be sent into the runtime as part of the\nmessage being sent. The tokens are transferred before the message is processed\nby the runtime."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"data")," arbitrary data to be sent to the runtime for processing.")),(0,a.kt)("p",null,"The transaction signer implicitly specifies the caller. Upon executing the\nsubmit message method the following actions are performed:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Gas is accounted for (new ",(0,a.kt)("inlineCode",{parentName:"p"},"submitmsg")," gas operation).")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"The runtime descriptor for runtime ",(0,a.kt)("inlineCode",{parentName:"p"},"id")," is retrieved. If the runtime does not\nexist or is currently suspended the method fails with ",(0,a.kt)("inlineCode",{parentName:"p"},"ErrInvalidRuntime"),".")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"The ",(0,a.kt)("inlineCode",{parentName:"p"},"txn_scheduler.max_in_messages")," field in the runtime descriptor is\nchecked. If it is equal to zero the method fails with\n",(0,a.kt)("inlineCode",{parentName:"p"},"ErrIncomingMessageQueueFull"),".")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"If the value of the ",(0,a.kt)("inlineCode",{parentName:"p"},"fee")," field is smaller than the value of the\n",(0,a.kt)("inlineCode",{parentName:"p"},"staking.min_in_msg_fee")," field in the runtime descriptor the method fails with\n",(0,a.kt)("inlineCode",{parentName:"p"},"ErrIncomingMessageInsufficientFee"),".")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"The number of tokens corresponding to ",(0,a.kt)("inlineCode",{parentName:"p"},"fee + tokens")," are moved from the\ncaller's account into the runtime account. If there is insufficient balance to\ndo so the method fails with ",(0,a.kt)("inlineCode",{parentName:"p"},"ErrInsufficientBalance"),".")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"The incoming queue metadata structure is fetched. If it doesn't yet exist it\nis populated with zero values.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"If the value of the ",(0,a.kt)("inlineCode",{parentName:"p"},"size")," field in the metadata structure is equal to or\nlarger than the value of the ",(0,a.kt)("inlineCode",{parentName:"p"},"txn_scheduler.max_in_messages")," field in the\nruntime descriptor the method fails with ",(0,a.kt)("inlineCode",{parentName:"p"},"ErrIncomingMessageQueueFull"),".")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"An ",(0,a.kt)("inlineCode",{parentName:"p"},"IncomingMessage")," structure is generated based on the caller and method\nbody and the value of the ",(0,a.kt)("inlineCode",{parentName:"p"},"next_sequence_number")," metadata field is used to\ngenerate a proper key for storing it in the queue. The structure is inserted\ninto the queue.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"The ",(0,a.kt)("inlineCode",{parentName:"p"},"size")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"next_sequence_number")," fields are incremented and the updated\nmetadata is saved."))),(0,a.kt)("h3",{id:"queries"},"Queries"),(0,a.kt)("p",null,"This proposal adds the following new query methods in the roothash module by\nupdating the ",(0,a.kt)("inlineCode",{parentName:"p"},"roothash.Backend")," interface as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-golang"},'type Backend interface {\n    // ... existing methods omitted ...\n\n    // GetIncomingMessageQueueMeta returns the given runtime\'s incoming message queue metadata.\n    GetIncomingMessageQueueMeta(ctx context.Context, request *RuntimeRequest) (*message.IncomingMessageQueueMeta, error)\n\n    // GetIncomingMessageQueue returns the given runtime\'s queued incoming messages.\n    GetIncomingMessageQueue(ctx context.Context, request *InMessageQueueRequest) ([]*message.IncomingMessage, error)\n}\n\n// IncomingMessageQueueMeta is the incoming message queue metadata.\ntype IncomingMessageQueueMeta struct {\n    // Size contains the current size of the queue.\n    Size uint32 `json:"size,omitempty"`\n\n    // NextSequenceNumber contains the sequence number that should be used for the next queued\n    // message.\n    NextSequenceNumber uint64 `json:"next_sequence_number,omitempty"`\n}\n\n// InMessageQueueRequest is a request for queued incoming messages.\ntype InMessageQueueRequest struct {\n    RuntimeID common.Namespace `json:"runtime_id"`\n    Height    int64            `json:"height"`\n\n    Offset uint64 `json:"offset,omitempty"`\n    Limit  uint32 `json:"limit,omitempty"`\n}\n')),(0,a.kt)("h3",{id:"runtime-host-protocol"},"Runtime Host Protocol"),(0,a.kt)("p",null,"This proposal updates the existing host to runtime requests in the runtime host\nprotocol as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-golang"},'type RuntimeExecuteTxBatchRequest struct {\n    // ... existing fields omitted ...\n\n    // IncomingMessages are the incoming messages from the consensus layer that\n    // should be processed by the runtime in this round.\n    IncomingMessages []*IncomingMessage `json:"in_messages,omitempty"`\n}\n')),(0,a.kt)("h3",{id:"rust-runtime-support-library"},"Rust Runtime Support Library"),(0,a.kt)("p",null,"This proposal updates the ",(0,a.kt)("inlineCode",{parentName:"p"},"transaction::Dispatcher")," trait as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"pub trait Dispatcher: Send + Sync {\n    // ... existing unchanged methods omitted ...\n\n    /// Execute the transactions in the given batch.\n    fn execute_batch(\n        &self,\n        ctx: Context,\n        batch: &TxnBatch,\n        in_msgs: Vec<IncomingMessage>, // Added argument.\n    ) -> Result<ExecuteBatchResult, RuntimeError>;\n}\n")),(0,a.kt)("h3",{id:"executor-processing"},"Executor Processing"),(0,a.kt)("p",null,"The executor processing pipeline is changed such that pending incoming messages\nare queried before the next round starts and are then passed to the runtime via\nthe runtime host protocol."),(0,a.kt)("p",null,"The executor may perform checks to estimate resource use early, similarly to how\nchecks are performed for transactions as they arrive."),(0,a.kt)("h3",{id:"runtime-processing"},"Runtime Processing"),(0,a.kt)("p",null,"The proposal requires that messages are processed by the runtime in queue order\n(e.g. on each round ",(0,a.kt)("inlineCode",{parentName:"p"},"InMessagesCount")," messages are poped from the queue). This\nsimplifies the design but the runtimes need to carefully consider how much\nresources to allocate for executing messages (vs. regular transactions) in a\nround."),(0,a.kt)("p",null,'The runtime has full autonomy in choosing how many messages to execute as it\nis given the complete message batch. It should first compute how many messages\nto process by running them in "check" mode and computing how much gas (or other\nresources) they take and then choosing as many as fits.'),(0,a.kt)("p",null,"Specifying these details is left to the runtime implementation although the SDK\nis expected to adopt an approach with separate ",(0,a.kt)("inlineCode",{parentName:"p"},"max_inmsg_gas")," and\n",(0,a.kt)("inlineCode",{parentName:"p"},"max_inmsg_slots")," parameters which limits how resources are allocated for\nincoming message processing in each round. If a single message exceeds either of\nthese limits it will result in execution failure of that message."),(0,a.kt)("h3",{id:"root-hash-commitment-processing"},"Root Hash Commitment Processing"),(0,a.kt)("p",null,"The processing of executor commitments is modified as follows:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"No changes are made to the discrepancy detection and resolution protocols\nbesides the newly added fields being taken into account in discrepancy\ndetermination.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"After a successful round, the ",(0,a.kt)("inlineCode",{parentName:"p"},"InMessagesCount")," field of the compute body is\nchecked and the corresponding number of messages are popped from the queue in\nincreasing order of their sequence numbers. The queue metadata is updated\naccoordingly by decrementing the value of the ",(0,a.kt)("inlineCode",{parentName:"p"},"size")," field and the\n",(0,a.kt)("inlineCode",{parentName:"p"},"InMessagesHash")," is added to the newly emitted block header."))),(0,a.kt)("h2",{id:"consequences"},"Consequences"),(0,a.kt)("h3",{id:"positive"},"Positive"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Consensus layer transactions can trigger actions in the runtime without\nadditional runtime transactions. This would also allow pushing tokens into\nthe runtime via a consensus layer transaction or even invoking smart contracts\nthat result in consensus layer actions to happen (via emitted messages).")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Each runtime can define the format of incoming messages. The SDK would likely\nuse something that contains a transaction (either signed to support\nnon-Ed25519 callers or unsigned for smaller Ed25519-based transactions) so\narbitrary invocations would be possible."))),(0,a.kt)("h3",{id:"negative"},"Negative"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Storing the queue will increase the size of consensus layer state.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"This could lead to incoming messages being used exclusively to interact with a\nruntime leading to the consensus layer getting clogged with incoming message\nsubmission transactions. Posting such messages would be more expensive though\nas it would require paying per transaction consensus layer fees in addition to\nthe runtime fees. If clogging does eventually happen the fees can be adjusted\nto encourage transaction submission to runtimes directly."))),(0,a.kt)("h3",{id:"neutral"},"Neutral"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Allows rollup-like constructions where all transactions are posted to the\nconsensus layer first and the runtime is just executing those.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Retrieving the result of processing an incoming message is more involved."))))}c.isMDXComponent=!0}}]);