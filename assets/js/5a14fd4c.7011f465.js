"use strict";(self.webpackChunkdocs_oasis_dev=self.webpackChunkdocs_oasis_dev||[]).push([[5115],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),p=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=p(e.components);return i.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=p(n),u=a,m=d["".concat(l,".").concat(u)]||d[u]||h[u]||o;return n?i.createElement(m,r(r({ref:t},c),{},{components:n})):i.createElement(m,r({ref:t},c))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,r[1]=s;for(var p=2;p<o;p++)r[p]=n[p];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}d.displayName="MDXCreateElement"},8690:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var i=n(7462),a=(n(7294),n(3905));const o={},r="ADR 0010: VRF-based Committee Elections",s={unversionedId:"adrs/0010-vrf-elections",id:"adrs/0010-vrf-elections",title:"ADR 0010: VRF-based Committee Elections",description:"Component",source:"@site/docs/adrs/0010-vrf-elections.md",sourceDirName:"adrs",slug:"/adrs/0010-vrf-elections",permalink:"/adrs/0010-vrf-elections",draft:!1,editUrl:"https://github.com/oasisprotocol/adrs/edit/main/0010-vrf-elections.md",tags:[],version:"current",lastUpdatedAt:1674490900,formattedLastUpdatedAt:"Jan 23, 2023",frontMatter:{},sidebar:"adrs",previous:{title:"ADR 0009: Ed25519 Signature Verification Semantics",permalink:"/adrs/0009-ed25519-semantics"},next:{title:"ADR 0011: Incoming Runtime Messages",permalink:"/adrs/0011-incoming-runtime-messages"}},l={},p=[{value:"Component",id:"component",level:2},{value:"Changelog",id:"changelog",level:2},{value:"Status",id:"status",level:2},{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Cryptographic Primitives",id:"cryptographic-primitives",level:3},{value:"Node Descriptor Changes",id:"node-descriptor-changes",level:3},{value:"Consensus Parameters",id:"consensus-parameters",level:3},{value:"Consensus State, Events, and Transactions",id:"consensus-state-events-and-transactions",level:3},{value:"VRF Operation",id:"vrf-operation",level:3},{value:"VRF Committee Elections",id:"vrf-committee-elections",level:3},{value:"VRF Validator Elections",id:"vrf-validator-elections",level:3},{value:"Timekeeping Changes",id:"timekeeping-changes",level:3},{value:"Consequences",id:"consequences",level:2},{value:"Positive",id:"positive",level:3},{value:"Negative",id:"negative",level:3},{value:"Neutral",id:"neutral",level:3},{value:"References",id:"references",level:2}],c={toc:p};function h(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,i.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"adr-0010-vrf-based-committee-elections"},"ADR 0010: VRF-based Committee Elections"),(0,a.kt)("h2",{id:"component"},"Component"),(0,a.kt)("p",null,"Oasis Core"),(0,a.kt)("h2",{id:"changelog"},"Changelog"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"2021-05-10: Initial version")),(0,a.kt)("h2",{id:"status"},"Status"),(0,a.kt)("p",null,"Accepted"),(0,a.kt)("h2",{id:"context"},"Context"),(0,a.kt)("p",null,"While functional, the current PVSS-based random beacon is neither all that\nperformant, nor all that scalable.  To address both concerns, this ADR\nproposes transitioning the election procedure to one that is based on\ncryptographic sortition of Verifiable Random Function (VRF) outputs."),(0,a.kt)("h2",{id:"decision"},"Decision"),(0,a.kt)("h3",{id:"cryptographic-primitives"},"Cryptographic Primitives"),(0,a.kt)("p",null,"Let the VRF to be used across the system be ECVRF-EDWARDS25519-SHA512-ELL2\nfrom the ",(0,a.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/draft-irtf-cfrg-vrf/"},"Verifiable Random Functions (VRFs) draft (v10)"),", with the\nfollowing additions and extra clarifications:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},'All public keys MUST be validated via the "ECVRF Validate Key" procedure\nas specified in section 5.6.1 (Small order public keys MUST be\nrejected).')),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"The string_to_point routine MUST reject non-canonically encoded points\nas specified in RFC 8032.  Many ed25519 implementations are lax about\nenforcing this when decoding.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"When decoding s in the ECVRF_verify routine, the s scalar MUST fall\nwithin the range 0 <= i < L.  This change will make proofs\nnon-malleable.  Note that this check is unneeded for the c scalar\nas it is 128-bits, and thus will always lie within the valid range.\nThis check was not present in the IETF draft prior to version 10.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Implementations MAY choose to incorporate additional randomness into\nthe ECVRF_nonce_generation_RFC8032 function.  Note that proofs (pi_string)\nare not guaranteed to be unique or deterministic even without this\nextension (the signer can use any arbitrary value for the nonce and\nproduce a valid proof, without altering beta_string)."))),(0,a.kt)("p",null,"Let the tuple oriented cryptographic hash function be TupleHash256 from\n",(0,a.kt)("a",{parentName:"p",href:"https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-185.pdf"},"NIST SP 800-185"),"."),(0,a.kt)("h3",{id:"node-descriptor-changes"},"Node Descriptor Changes"),(0,a.kt)("p",null,"The node descriptor of each node will be extended to include the following\ndatastructure."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-golang"},'type Node struct {\n  // ... existing fields omitted ...\n\n  // VRF is the public key used by the node to generate VRF proofs.\n  VRF *VRFInfo `json:"vrf,omitempty"`\n}\n\ntype VRFInfo struct {\n  // ID is the unique identifier of the node used to generate VRF proofs.\n  ID signature.PublicKey `json:"id"`\n}\n')),(0,a.kt)("p",null,"The VRF public key shall be a long-term Ed25519 public key, that is distinct\nfrom every other key used by the node.  The key MUST not be small order."),(0,a.kt)("p",null,"The existing ",(0,a.kt)("inlineCode",{parentName:"p"},"Beacon")," member of the node descriptor is considered deprecated\nand will first be ignored by the consensus layer, and then removed in a\nsubsequent version following a transitionary period."),(0,a.kt)("h3",{id:"consensus-parameters"},"Consensus Parameters"),(0,a.kt)("p",null,"The scheduler module will have the following additional consensus parameters\nthat control behavior."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-golang"},'type ConsensusParameters struct {\n  // ... existing fields omitted ...\n\n  // VRFParameters is the paramenters for the VRF-based cryptographic\n  // sortition based election system.\n  VRFParameters *VRFParameters `json:"vrf_params"`\n}\n\n// VRFParameters are the VRF scheduler parameters.\ntype VRFParameters struct {\n  // AlphaHighQualityThreshold is the minimum number of proofs (Pi)\n  // that must be received for the next input (Alpha) to be considered\n  // high quality.  If the VRF input is not high quality, runtimes will\n  // be disabled for the next epoch.\n  AlphaHighQualityThreshold uint64 `json:"alpha_hq_threshold,omitempty"`\n\n  // Interval is the epoch interval (in blocks).\n  Interval int64 `json:"interval,omitempty"`\n\n  // ProofSubmissionDelay is the wait peroid in blocks after an epoch\n  // transition that nodes MUST wait before attempting to submit a\n  // VRF proof for the next epoch\'s elections.\n  ProofSubmissionDelay int64 `json:"proof_delay,omitempty"`\n\n  // PrevState is the VRF state from the previous epoch, for the\n  // current epoch\'s elections.\n  PrevState *PrevVRFState `json:"prev_state,omitempty"`\n}\n\n// PrevVRFState is the previous epoch\'s VRF state that is to be used for\n// elections.\ntype PrevVRFState struct {\n  // Pi is the accumulated pi_string (VRF proof) outputs for the\n  // previous epoch.\n  Pi map[signature.PublicKey]*signature.Proof `json:"pi.omitempty"`\n\n  // CanElectCommittees is true iff the previous alpha was generated\n  // from high quality input such that committee elections are possible.\n  CanElectCommittees bool `json:"can_elect,omitempty"`\n}\n\n')),(0,a.kt)("h3",{id:"consensus-state-events-and-transactions"},"Consensus State, Events, and Transactions"),(0,a.kt)("p",null,"The scheduler component will maintain and make available the following additonal\nconsensus state."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-golang"},'// VRFState is the VRF scheduler state.\ntype VRFState struct {\n  // Epoch is the epoch for which this alpha is valid.\n  Epoch EpochTime `json:"epoch"`\n\n  // Alpha is the active VRF alpha_string input.\n  Alpha []byte `json:"alpha"`\n\n  // Pi is the accumulated pi_string (VRF proof) outputs.\n  Pi map[signature.PublicKey]*signature.Proof `json:"pi,omitempty"`\n\n  // AlphaIsHighQuality is true iff the alpha was generated from\n  // high quality input such that elections will be possible.\n  AlphaIsHighQuality bool `json:"alpha_hq"`\n\n  // SubmitAfter is the block height after which nodes may submit\n  // VRF proofs for the current epoch.\n  SubmitAfter int64 `json:"submit_after"`\n}\n')),(0,a.kt)("p",null,"Implementations MAY cache the beta_string values that are generated from valid\npi_strings for performance reasons, however as this is trivial to recalculate,\nit does not need to be explicitly exposed."),(0,a.kt)("p",null,"Upon epoch transition, the scheduler will emit the following event."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-golang"},'// VRFEvent is the VRF scheduler event.\ntype VRFEvent struct {\n  // Epoch is the epoch that Alpha is valid for.\n  Epoch EpochTime `json:"epoch,omitempty"`\n\n  // Alpha is the active VRF alpha_string input.\n  Alpha []byte `json:"alpha,omitempty"`\n\n  // SubmitAfter is the block height after which nodes may submit\n  // VRF proofs for the current epoch.\n  SubmitAfter int64 `json:"submit_after"`\n}\n\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-golang"},'type VRFProve struct {\n  // Epoch is the epoch that this VRF proof is for.\n  Epoch epochtime.EpochTime `json:"epoch"`\n\n  // Pi is the VRF proof for the current epoch.\n  Pi     []byte              `json:"pi"`\n}\n')),(0,a.kt)("h3",{id:"vrf-operation"},"VRF Operation"),(0,a.kt)("p",null,"For the genesis epoch, let the VRF alpha_string input be derived as:"),(0,a.kt)("p",null,"  ",(0,a.kt)("inlineCode",{parentName:"p"},'TupleHash256((chain_context, I2OSP(epoch,8)), 256, "oasis-core:vrf/alpha")')),(0,a.kt)("p",null,"For every subsequent epoch, let alpha_string be derived as:"),(0,a.kt)("p",null,"  ",(0,a.kt)("inlineCode",{parentName:"p"},'TupleHash256((chain_context, I2OSP(epoch, 8), beta_0, ... beta_n), 256, "oasis-core:vrf/alpha")')),(0,a.kt)("p",null,'where beta_0 through beta_n are the beta_string outputs gathered from\nall valid pi_strings submitted during the previous epoch (after the\non-transition culling is complete), in ascending lexographic order by\nVRF key.  If the number of beta values incorporated into the TupleHash\ncomputation is greater than or equal to AlphaHighQuality threshold,\nthe alpha is considered "strong", and committee elections are allowed\nbased on the proofs generated with this alpha.  If the alpha value is\nweak (insufficient nodes submitted proofs), only validator elections\nare allowed.'),(0,a.kt)("p",null,"Upon receiving a VRFEvent, all eligible nodes MUST wait a minimum of\nProofSubmissionDelay blocks, and then submit a VRFProve transaction,\nwith the Proof field set to the output of\n",(0,a.kt)("inlineCode",{parentName:"p"},"ECVRF_prove(VRFKey_private, alpha_string)"),"."),(0,a.kt)("p",null,"Upon receiving a VRFProve transaction, the scheduler does the following:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Rejects the transaction if less than ProofSubmissionDelay blocks\nhave elapsed since the transition into the current epoch.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Checks to see if the node tentatively eligible to be included in\nthe next election according to the following criteria:"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Not frozen.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Has registered the VRF.ID used to generate the proof prior\nto the transition into the current epoch (May slash).")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Has not already submitted a proof for the current epoch\n(May slash if proof is different).")))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Validates the proof, and if valid, stores the VRF.ID + pi_string\nin the consensus state."))),(0,a.kt)("h3",{id:"vrf-committee-elections"},"VRF Committee Elections"),(0,a.kt)("p",null,"The following changes are made to the committee election process."),(0,a.kt)("p",null,"On epoch transition, as long as the alpha used to generate the proofs\nis considered strong re-validate node eligibility for all nodes that\nsubmitted a VRF proof (Not frozen, VRF.ID has not changed), and cull\nproofs from nodes that are now ineligible."),(0,a.kt)("p",null,"If the alpha value is considered weak, no commitee elections are allowed."),(0,a.kt)("p",null,"For each committee:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Filter the node list based on the current stake/eligibility criteria,\nand additionally filter out nodes that have not submitted a valid\nVRF proof.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"For each eligible (node, commitee kind, committe role) tuple, derive\na sortition string as:"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'`s_n = TupleHash256((chain_context, I2OSP(epoch, 8), runtime_id, I2OSP(kind, 1), I2OSP(role, 1), beta_n), 256, "oasis-core:vrf/committee")`\n')),(0,a.kt)("ol",{start:3},(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Sort s_0 ... s_n in ascending lexographical order.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Select the requisite nodes that produced the sortition strings\nstarting from the head of the sorted list as the committee."))),(0,a.kt)("p",null,"Committee elections MUST be skipped for the genesis and subsequent epoch,\nas the genesis epoch has no VRF proofs, and proofs submitted during the\ngenesis epoch are based on the bootstrap alpha_string."),(0,a.kt)("h3",{id:"vrf-validator-elections"},"VRF Validator Elections"),(0,a.kt)("p",null,"The only place where the beacon is currently used in the validator selection\nprocess is to pick a single node out of multiple eligible nodes controlled by\nthe same entity to become a validator."),(0,a.kt)("p",null,"When this situation occurs the validator is selected as follows:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"For all validator-eligible nodes controlled by the given entity,\nderive a sortition string as:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},' `s_n = TupleHash256((chain_context, I2OSP(epoch, 8), beta_n), 256, "oasis-core:vrf/validator")`\n')),(0,a.kt)("ol",{start:2},(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Sort s_0 ... s_n, in ascending lexographic order.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Select the node that produced the 0th sortition string in the sorted\nlist as the validator."))),(0,a.kt)("p",null,"This is safe to do with beta values generated via the bootstrap alpha string\nas it is up to the entity running the nodes in question as to which ones\nare a validator anyway."),(0,a.kt)("p",null,"As a concession for the transition process, if the number of validators\nthat submit proofs is less than the minimum number of validators configured\nin the scheduler, validator tie-breaks (and only validator tie-breaks)\nwill be done by permuting the node list (as in the current PVSS beacon),\nusing entropy from the block hash."),(0,a.kt)("p",null,"As nodes are required to submit a VRF public key as part of non-genesis\nregistrations, and each node will attempt to submit a VRF proof, this\nbackward compatibility hack should only be triggered on the genesis\nepoch, and can be removed on the next major upgrade."),(0,a.kt)("h3",{id:"timekeeping-changes"},"Timekeeping Changes"),(0,a.kt)("p",null,"Timekeeping will go back to a fixed-interval epoch transition mechanism, with\nall of the beacon related facilities removed.  As this is primarily a module\nrename and code removal, the exact details are left unspecified."),(0,a.kt)("h2",{id:"consequences"},"Consequences"),(0,a.kt)("h3",{id:"positive"},"Positive"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"This is significantly simpler from a design standpoint.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"This is significantly faster and scales significantly better.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"It is possible to go back to fixed-length epochs again."))),(0,a.kt)("h3",{id:"negative"},"Negative"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"The system loses a way to generate entropy at the consensus layer.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"The simple design involves an additional 1-epoch period after network\ninitialization where elections are not available."))),(0,a.kt)("h3",{id:"neutral"},"Neutral"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"I need to implement TupleHash256.")),(0,a.kt)("h2",{id:"references"},"References"))}h.isMDXComponent=!0}}]);